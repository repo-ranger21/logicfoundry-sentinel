"""
remediator.py - Automated Remediation Engine

Generates fix scripts (Ansible playbooks, shell scripts) based on vulnerabilities.
"""

import os
from typing import Optional
from dataclasses import dataclass
from enum import Enum


class RemediationType(Enum):
    """Types of remediation actions."""
    ANSIBLE = "ansible"
    SHELL = "shell"
    FIREWALL = "firewall"
    CONFIG = "config"


@dataclass
class RemediationAction:
    """Represents a remediation action to fix a vulnerability."""
    vulnerability_desc: str
    action_type: RemediationType
    description: str
    script: str
    requires_reboot: bool = False
    risk_level: str = "low"  # low, medium, high


class Remediator:
    """
    Generates automated remediation scripts for detected vulnerabilities.
    """
    
    def __init__(self, output_dir: str = "./remediation"):
        self.output_dir = output_dir
        self.actions: list[RemediationAction] = []
        
    def generate_remediation(self, vulnerabilities: list) -> list[RemediationAction]:
        """
        Generate remediation actions for a list of vulnerabilities.
        
        Args:
            vulnerabilities: List of Vulnerability objects from analyzer
            
        Returns:
            list: RemediationAction objects
        """
        self.actions = []
        
        for vuln in vulnerabilities:
            action = self._get_remediation_for_vuln(vuln)
            if action:
                self.actions.append(action)
        
        return self.actions
    
    def _get_remediation_for_vuln(self, vuln) -> Optional[RemediationAction]:
        """Get appropriate remediation for a vulnerability."""
        
        # Port-based remediations
        port_remediations = {
            23: self._remediate_telnet,
            21: self._remediate_ftp,
            445: self._remediate_smb,
            3389: self._remediate_rdp,
            5900: self._remediate_vnc,
        }
        
        if vuln.port in port_remediations:
            return port_remediations[vuln.port](vuln)
        
        # Service-based remediations
        service_remediations = {
            "ssh": self._remediate_ssh,
            "http": self._remediate_http,
            "mysql": self._remediate_mysql,
        }
        
        if vuln.service in service_remediations:
            return service_remediations[vuln.service](vuln)
        
        return None
    
    def _remediate_telnet(self, vuln) -> RemediationAction:
        """Generate remediation for open Telnet port."""
        ansible_script = """---
# Ansible Playbook: Disable Telnet Service
# Generated by Sentinel-AutoFix

- name: Disable Telnet and enforce SSH
  hosts: all
  become: yes
  tasks:
    - name: Stop telnet service
      service:
        name: telnet
        state: stopped
        enabled: no
      ignore_errors: yes

    - name: Remove telnet package (Debian/Ubuntu)
      apt:
        name: telnetd
        state: absent
      when: ansible_os_family == "Debian"

    - name: Remove telnet package (RHEL/CentOS)
      yum:
        name: telnet-server
        state: absent
      when: ansible_os_family == "RedHat"

    - name: Block port 23 with iptables
      iptables:
        chain: INPUT
        protocol: tcp
        destination_port: 23
        jump: DROP
        state: present

    - name: Ensure SSH is installed and running
      service:
        name: sshd
        state: started
        enabled: yes
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.ANSIBLE,
            description="Disable Telnet service and block port 23",
            script=ansible_script,
            requires_reboot=False,
            risk_level="low"
        )
    
    def _remediate_ftp(self, vuln) -> RemediationAction:
        """Generate remediation for FTP vulnerabilities."""
        shell_script = """#!/bin/bash
# Shell Script: Secure FTP Configuration
# Generated by Sentinel-AutoFix

echo "[*] Securing FTP configuration..."

# Option 1: Disable FTP entirely (recommended)
# systemctl stop vsftpd
# systemctl disable vsftpd

# Option 2: If FTP is required, enable TLS
if [ -f /etc/vsftpd/vsftpd.conf ]; then
    echo "[*] Configuring vsftpd for TLS..."
    
    # Backup original config
    cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak
    
    # Enable TLS
    cat >> /etc/vsftpd/vsftpd.conf << EOF

# SSL/TLS Configuration (Added by Sentinel-AutoFix)
ssl_enable=YES
allow_anon_ssl=NO
force_local_data_ssl=YES
force_local_logins_ssl=YES
ssl_tlsv1=YES
ssl_sslv2=NO
ssl_sslv3=NO
require_ssl_reuse=NO
ssl_ciphers=HIGH
EOF

    systemctl restart vsftpd
    echo "[+] FTP TLS configuration applied"
else
    echo "[!] vsftpd config not found at /etc/vsftpd/vsftpd.conf"
fi

echo "[+] Consider switching to SFTP (SSH File Transfer Protocol) instead"
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.SHELL,
            description="Enable TLS for FTP or disable the service",
            script=shell_script,
            requires_reboot=False,
            risk_level="medium"
        )
    
    def _remediate_smb(self, vuln) -> RemediationAction:
        """Generate remediation for SMB vulnerabilities."""
        ansible_script = """---
# Ansible Playbook: Secure SMB/Samba Configuration
# Generated by Sentinel-AutoFix

- name: Secure SMB/Samba
  hosts: all
  become: yes
  tasks:
    - name: Update Samba to latest version
      package:
        name: samba
        state: latest

    - name: Disable SMBv1 (vulnerable to EternalBlue)
      lineinfile:
        path: /etc/samba/smb.conf
        regexp: '^\\s*min protocol'
        line: '   min protocol = SMB2'
        insertafter: '\\[global\\]'
      notify: restart samba

    - name: Set max protocol to SMB3
      lineinfile:
        path: /etc/samba/smb.conf
        regexp: '^\\s*max protocol'
        line: '   max protocol = SMB3'
        insertafter: '\\[global\\]'
      notify: restart samba

    - name: Block external SMB access
      iptables:
        chain: INPUT
        protocol: tcp
        destination_port: 445
        source: '!192.168.0.0/16'
        jump: DROP
        state: present

  handlers:
    - name: restart samba
      service:
        name: smbd
        state: restarted
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.ANSIBLE,
            description="Update Samba and disable SMBv1",
            script=ansible_script,
            requires_reboot=False,
            risk_level="medium"
        )
    
    def _remediate_rdp(self, vuln) -> RemediationAction:
        """Generate remediation for exposed RDP."""
        script = """#!/bin/bash
# Shell Script: Secure RDP Access
# Generated by Sentinel-AutoFix

echo "[*] Securing RDP configuration..."

# Block RDP from public internet (allow only from internal networks)
iptables -A INPUT -p tcp --dport 3389 -s 192.168.0.0/16 -j ACCEPT
iptables -A INPUT -p tcp --dport 3389 -s 10.0.0.0/8 -j ACCEPT
iptables -A INPUT -p tcp --dport 3389 -j DROP

echo "[+] RDP now only accessible from internal networks"
echo "[!] Consider using a VPN for remote access instead"
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.FIREWALL,
            description="Restrict RDP access to internal networks",
            script=script,
            requires_reboot=False,
            risk_level="low"
        )
    
    def _remediate_vnc(self, vuln) -> RemediationAction:
        """Generate remediation for exposed VNC."""
        script = """#!/bin/bash
# Shell Script: Secure VNC Configuration
# Generated by Sentinel-AutoFix

echo "[*] Securing VNC..."

# Option 1: Block VNC from external access
iptables -A INPUT -p tcp --dport 5900:5910 -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -p tcp --dport 5900:5910 -j DROP

echo "[+] VNC now only accessible via SSH tunnel"
echo ""
echo "To connect securely, use SSH tunneling:"
echo "  ssh -L 5900:localhost:5900 user@server"
echo "  Then connect VNC client to localhost:5900"
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.FIREWALL,
            description="Restrict VNC to localhost (use SSH tunnel)",
            script=script,
            requires_reboot=False,
            risk_level="low"
        )
    
    def _remediate_ssh(self, vuln) -> RemediationAction:
        """Generate remediation for SSH vulnerabilities."""
        ansible_script = """---
# Ansible Playbook: Upgrade and Harden SSH
# Generated by Sentinel-AutoFix

- name: Upgrade and Harden OpenSSH
  hosts: all
  become: yes
  tasks:
    - name: Update OpenSSH to latest version
      package:
        name: openssh-server
        state: latest
      notify: restart sshd

    - name: Harden SSH configuration
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^#?PermitRootLogin', line: 'PermitRootLogin no' }
        - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication no' }
        - { regexp: '^#?X11Forwarding', line: 'X11Forwarding no' }
        - { regexp: '^#?MaxAuthTries', line: 'MaxAuthTries 3' }
        - { regexp: '^#?Protocol', line: 'Protocol 2' }
      notify: restart sshd

  handlers:
    - name: restart sshd
      service:
        name: sshd
        state: restarted
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.ANSIBLE,
            description="Upgrade OpenSSH and apply hardening",
            script=ansible_script,
            requires_reboot=False,
            risk_level="medium"
        )
    
    def _remediate_http(self, vuln) -> RemediationAction:
        """Generate remediation for HTTP/Apache vulnerabilities."""
        script = """#!/bin/bash
# Shell Script: Update Apache Web Server
# Generated by Sentinel-AutoFix

echo "[*] Updating Apache..."

# Detect package manager and update
if command -v apt-get &> /dev/null; then
    apt-get update
    apt-get install -y apache2
elif command -v yum &> /dev/null; then
    yum update -y httpd
fi

# Restart Apache
systemctl restart apache2 2>/dev/null || systemctl restart httpd

echo "[+] Apache updated to latest version"
echo "[*] Verify version with: apache2 -v or httpd -v"
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.SHELL,
            description="Update Apache to latest patched version",
            script=script,
            requires_reboot=False,
            risk_level="low"
        )
    
    def _remediate_mysql(self, vuln) -> RemediationAction:
        """Generate remediation for MySQL vulnerabilities."""
        ansible_script = """---
# Ansible Playbook: Upgrade MySQL
# Generated by Sentinel-AutoFix

- name: Upgrade MySQL Server
  hosts: all
  become: yes
  tasks:
    - name: Update MySQL (Debian/Ubuntu)
      apt:
        name: mysql-server
        state: latest
      when: ansible_os_family == "Debian"
      notify: restart mysql

    - name: Update MySQL (RHEL/CentOS)
      yum:
        name: mysql-server
        state: latest
      when: ansible_os_family == "RedHat"
      notify: restart mysql

    - name: Run mysql_secure_installation equivalent
      mysql_user:
        name: root
        host: localhost
        password: "{{ mysql_root_password }}"
        priv: '*.*:ALL,GRANT'
        state: present
      ignore_errors: yes

  handlers:
    - name: restart mysql
      service:
        name: mysql
        state: restarted
"""
        return RemediationAction(
            vulnerability_desc=vuln.description,
            action_type=RemediationType.ANSIBLE,
            description="Upgrade MySQL to supported version",
            script=ansible_script,
            requires_reboot=False,
            risk_level="high"
        )
    
    def export_playbooks(self) -> list[str]:
        """
        Export all remediation scripts to files.
        
        Returns:
            list: Paths to generated files
        """
        os.makedirs(self.output_dir, exist_ok=True)
        generated_files = []
        
        for i, action in enumerate(self.actions):
            if action.action_type == RemediationType.ANSIBLE:
                filename = f"playbook_{i+1:02d}_{action.action_type.value}.yml"
            else:
                filename = f"remediate_{i+1:02d}_{action.action_type.value}.sh"
            
            filepath = os.path.join(self.output_dir, filename)
            
            with open(filepath, 'w') as f:
                f.write(f"# Remediation for: {action.vulnerability_desc}\n")
                f.write(f"# Risk Level: {action.risk_level}\n")
                f.write(f"# Requires Reboot: {action.requires_reboot}\n\n")
                f.write(action.script)
            
            generated_files.append(filepath)
            print(f"[+] Generated: {filepath}")
        
        return generated_files
    
    def get_summary(self) -> str:
        """Generate a summary of remediation actions."""
        lines = [
            "=" * 60,
            "REMEDIATION SUMMARY",
            "=" * 60,
            f"\nTotal Actions: {len(self.actions)}",
            ""
        ]
        
        for i, action in enumerate(self.actions, 1):
            lines.append(f"{i}. [{action.action_type.value.upper()}] {action.description}")
            lines.append(f"   For: {action.vulnerability_desc}")
            lines.append(f"   Risk: {action.risk_level}")
            lines.append("")
        
        return "\n".join(lines)


# CLI Entry Point
if __name__ == "__main__":
    # Mock vulnerability data for testing
    from analyzer import Vulnerability, Severity
    
    mock_vulns = [
        Vulnerability(port=23, service="telnet", 
                     description="Telnet exposed on port 23",
                     severity=Severity.HIGH, remediation_available=True),
        Vulnerability(port=445, service="smb",
                     description="SMBv1 vulnerable to EternalBlue",
                     severity=Severity.CRITICAL, remediation_available=True),
        Vulnerability(port=22, service="ssh",
                     description="OpenSSH 7.4 - outdated version",
                     severity=Severity.MEDIUM, remediation_available=True),
    ]
    
    remediator = Remediator()
    actions = remediator.generate_remediation(mock_vulns)
    
    print(remediator.get_summary())
    
    # Export to files
    print("\nGenerating remediation scripts...")
    files = remediator.export_playbooks()
    print(f"\n[+] Generated {len(files)} remediation scripts")
